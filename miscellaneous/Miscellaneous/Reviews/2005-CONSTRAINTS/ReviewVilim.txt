----------------------------------------------------------------------
      Paper review  for the  Special  Issue on CP'2004

----------------------------------------------------------------------
Paper title: 

Extension of O(n log(n)) filtering algorithms for the unary resource
constraint to optional activities

Authors: Petr Vilim, Roman Bartak and Ondrej Cepek

----------------------------------------------------------------------
Significance: 

Efficient filtering algorithms are a key component of constraint-based
scheduling. This article describes some new variants of classical
filtering algorithms on unary resources that achieve a theoretical
complexity per propagation step in O(n log n) thanks to a particular
structure called theta-trees. A new efficient algorithm for filtering
detectable precedences is also described. 

In real scheduling applications, the notion of optional requirement of
a resource by an activity is often crucial (for instance to model
optional activities or alternative resources). Most of the new
algorithm introduced in the paper are generalised to the case of
optional resource requirements keeping the same complexity in O(n log n).

So the paper addresses two very significant issues: efficiency of
filtering algorithms and extensions of those algorithms to tackle more
realistic models.

----------------------------------------------------------------------
Originality: 

This article is an extension of two previous works published at
CP-2004 (Unary Resource Constraint with Optional Activities) and
CP-AI-OR-2004 (O(n log n) Filtering Algorithms for unary resource
constraints).

Although the ideas of the filtering algorithms are not original (but
for the detectable precedences filtering), the notion of theta-tree to
speed-up classical filtering algorithms is an original contribution of
the authors.

Since the original work published for CP-AI-OR-2004, an important
effort has been made to simplify the theta-tree structure, its
presentation together with the presentation of the filtering
algorithms that exploit this structure. Furthermore, the original
study has been extended to provide O(n log n) algorithms for filtering
with optional activities.

----------------------------------------------------------------------
Quality: 

The new theta-tree structure is (now) really very simple. That's an
important contribution of the present paper.

The paper lacks some kind of conclusion and description of how the
present contribution could be extended. For instance, some of the
filtering algorithms studied in this paper are available for the more
general case of cumulative resources (e.g. edge-finding). Is the
corresponding extension of the O(n log n) version straightforward ? If
we restrict ourselves to unary resources, what about an edge-finding
algorithm with optional activities in O( n log n) ? Could we imagine
some kind of theta-lambda-xi trees with a second layer of optional
activities ?

----------------------------------------------------------------------
Clarity: 

Globally, the paper is well written and, for each filtering algorithm,
the usage of the theta-trees, especially the order in which activities
are added into the tree, is well explained.

The paper's organisation could, I think, be improved by presenting
Section 6.1 on theta-lambda-trees after the introduction of
theta-trees in section 2. This way, section 2 would be fully dedicated
to the description of the basic structures and later sections (3-7) to
the use of these basic structures for filtering. In general, notations
could be improved as they mix functional notations (e.g. right(v))
with subscript notations (e.g. ECT_v).

----------------------------------------------------------------------
Detailed comments: 

p1. "A unary resource models a set of non-interruptible activities
...". Usually, the non-interruptibility status is associated with
activities, not with the notion of unary resource. 

p2 and in many places (also p6, p13): "then" is used instead of "than"

p3. The notation \SigmaP_v for the total processing time of all the
leaves of a node v is slightly ambiguous because it looks like a sum
over a set of P indexed by v. I suggest only using P_v.

p3, last line. One should read Right(v) instead of Right(i)

p4. The theoretical complexity in O(n log n) relies on the fact
theta-trees are balanced. It is not clear from the last paragraph in
section 2 how the "fixed" tree shape is computed. Does it use the time
bounds on activities (est) after the initial propagation to build a
balanced binary tree whose structure is then re-used ? What is meant
by "the shape of the tree is fixed during the whole computation" ? How
is this structure re-used during the search as most of the time, at
each propagation, theta-trees seem to be re-built from scratch
(e.g. first line of algorithm for overload checking on p6).

p5. Last paragraph. ECT_\Theta(j). (j) should also be written as
subscript.

p6. In the presentation of the not-first/not-last filtering algorithm,
the efficiency of one step of the algorithm in O(n log(n)) seems to be
counter-balanced by the fact the number of steps to reach the fix
point increases. Actually, the algorithm seems to maximise this number
of steps. Besides the experimental evaluation, are there some
theoretical arguments in favour of the idea that the proposed O(n
log(n)) algorithms are more efficient than more expensive versions of
the algorithms that would need less steps to converge to the
fix-point ?

p17. After the description of the different ways to handle optional
activities, it should be explicitly stated that the proposed approach
is a "modified filtering algorithm". It should be noted that the use
of cumulative resources alone is in general not enough and partially
covers only the case of alternative machines.

p21. In the section about experiments, it is difficult to see how fair
is the comparison between the proposed algorithms and the quadratic
implementation of the classical version. One can imagine that as the
quadratic implementations use more simple structures, some simple
implementation tricks are easier to implement there than on the O(n
log n) version with theta-trees. Something should be said about how
the quadratic versions were implemented. It would also be useful to
identify for each problem how much time is spent in the different
filtering algorithms (both in O(n log(n)) and quadratic version) in
order to identify the bottlenecks and which are the filtering
algorithms that benefit the most from the theta-tree structure.

----------------------------------------------------------------------
Overall comment:

I recommend the acceptance of this article to the Constraints Special
Issue on CP'2004. 

----------------------------------------------------------------------
Reviewer: Philippe Laborie
