
General recommandation:
[ ] Accept
[ ] Minor revision
[X] Major revision
[ ] Reject

Overall Manuscript Rating (1 - 100):


Reviewer Blind Comments to Author:


The paper deals with a very interesting and relevant scheduling problem: the flexible job-shop with parallel batch machines. This problem is particularly important in the semiconductor industry.

Although the models and the concepts used through the paper are quite simple, the article is really hard to follow. This is partly due to the poor English, to many typos/errors/imprecisions but also to a lack of description of what the author is trying to achieve with the different versions of the models.

Following a description of the context of the work in section 1 and 2, section 3.1 introduces a MIP model for the FJSP with batching. This section is the most comprehensible one. The proposed MIP model, which to the best of my knowledge is original (even if it appears quite straightforward) is the main contribution of the paper. Still, this section could be improved:
- As mentioned by the author, the problem assumes that all jobs are compatible so that any two steps scheduled on the same machine can be batched together. In the semiconductor problems, there are often different families of jobs (and even steps) so that two steps of different family cannot be batched together. It would be interesting to mention how this feature could be integrated in the proposed MIP model.
- In the description of the MIP model, instead of using the term "sequence" for "k" I would rather use something like "position" in the sequence. For instance: "X_jsmk is 1 if step s of job j occupies position k in the sequence of machine m". This is more clear than the current "X_jsmk is 1 if job j occupies sequence k in the sequence on machine m at step s". This is just an example of the very awkward formulations that, all along the paper, make it difficult to read.
- Also, pay attention to the notations:
  * For instance parameter par^release_j is used in the MIP but not described in the parameters
  * Makespan is sometimes denoted C_max, sometimes Cmax, sometimes CMAX, then J^arrival sometimes J^Arrival, etc.
  * Simplify when possible: for instance "J^arrival_i = par^realease_j forall j,s=1". Why not: "J^arrival_1 = par^realease_j forall j" ?

Section 3.2 introduces the notion of optional job: "... we found that the [MIP] model can not generate an effective solution for a large instances (sic) after several hours of computational time so we explorer (sic) an opportunity of practical modification in order to address a real-world scheduling problem". As we will see later, the mentioned "modifications" are not really clear but, what is even more annoying, is that it is never said what is the *nature* of these modifications. Is it "relaxations" of the original problem (so that even if they provide non feasible solution they can be used to compute a lower-bound on the problem; is it "equivalent" reformulations of the problem that maintains the same set of optimal solutions; is it "over-constrained" modifications that result in a more constrained problem that maintains the feasibility of the produced solutions but no guarantee of optimality; or just some more general "approximations" of the original problem ? The main advantage of MIP models for scheduling is that they an provide some guarantees on the solution quality (optimality certificates, gap). Except for the case your model modifications are "equivalent" formulations or "relaxations", they cannot bring any guarantee on the solution quality and you lose the advantage of using a MIP compared to alternative approaches as for instance meta-heuristics that can provide high-quality solutions to large instances of the problem.

The first variant described in item (a) in section 3.2 is not clear. I understand that jobs are optional and that the objective is to maximize the number of executed jobs (equation 2.3). But if there are no limitations on the makespan (and no deadlines on the jobs), it is clear that an optimal solution to this model consists in executing all the jobs. What is the added value of this model? Also, I do not understand the statement that "M is the theoretical upper bound of Cmax". What is the theoretical upper bound of Cmax? Why do we need this apparently useless constant factor in the maximization objective "maximize sum M.X_{jsmk}" ?

Then "This change reduces a (sic) number of nodes in branch-and-bound algorithm owing to smaller |K|". It reduces the number of nodes compared to what? The model described in this section maximizes the number of executed jobs, how can it result in smaller |K|, how does it relate to the original problem of minimizing the makespan? My feeling is that you first use this model to compute a feasible solution with all the jobs scheduled (but such a feasible solution could be computed using any heuristic) and this solution is used to compute a maximal value for the number of steps executed by a machine, and that this maximal number of steps is used as additional constraint to limit the search space of the original model. In this case, this means that the resulting model FJSP^+Batching_Selective is an over-constrained problem compared to the original problem. But then an optimal solution to FJSP^+Batching_Selective is not necessarily an optimal solution for the original problem and this model cannot be used to give any solution quality guarantee for the original problem. On the same line, in the experimental section you cannot argument that "FJSP^+Batching_Selective is better than FJSP^+Batching because it finds more optimal solutions", just because (if I understand correctly), because FJSP^+Batching_Selective is over-constrained it can miss optimal solutions of the original problem.

The second variant is described in item (b): "Although there are minor variations of processing times, a machine has an equal processing time on different jobs in general. This compromise is acceptable for the sake of a reduced computational time." What compromise? I suppose it is the fact to consider that on a machine the processing time does not depend on the job compared to solving the real version of the problem where processing time are job-dependents. But then you should either show that this compromise is indeed acceptable (and the difference between Cmax values between Table 2 and Table 3 seem to suggest that processing times are highly job dependents otherwise you would get similar makespans whereas the optimal makespans computed with min values on Table 3 are about twice smaller that the ones on Table2) or take it for granted from the beginning and then only work with job-independent processing times.

Furthermore, in the description of this variant in item (b) you should say how the "common" processing time is computed for a given machine: is it the min/max/average of the actual job-dependent processing times? Which steps are considered: all the ones potentially executable by the machine? And then, again, if you use a 'min' (as the experimental section seems to suggest) you get a relaxation of the real problem so this can be used to compute lower bounds for the actual problem but there is not any guarantee about the actual quality of the solutions to this relaxed problem. 

The problem with priority jobs suffers the same issues as mentioned above: were job-dependent processing times somehow considered? How the two objectives mentioned in the model where "aggregated" ? What it the guarantee that setting |K| value to 4 does not rule out some optimal solutions? Also there are some inconsistencies in the description: Table 4 seems to suggest that "hot" jobs are optional whereas the description and the MIP model in appendix says that they "must" be scheduled. Also, isn't it surprising that among the 50 jobs of the benchmark, for all of the 10 instances it is exactly the same number of super-hot, hot and normal jobs that are effectively scheduled (resp. : 5, 5 and 10) ? Is it just by chance?

To summarize, I think there are interesting ideas in the MIP model proposed in section 3.1. But the "practical" improvements to this model need to be clarified. Furthermore, the presentation of the paper needs to be improved. 

A few more detailed comments:

- In the abstract: "We then turn job-dependent processing time into machine-dependent". This is a bit misleading, I would rather say that you turn job-dependent processing time into job-independent ones". Same in title of Table 3 and probably in other places too.

- In introduction :  "Last application which has yet been studied in the literature". Perhaps you mean "not yet"

- Section 2.1: "we explorer" -> "we explore[d]" There are other occurrences of this "explorer"

- For the benchmark used in section 4.1, you should mention the exact size of the instances (beside only mentioning small, medium and large size problems)

- Section 4.3: "We need to modify the the model ..."

- In the MIP model about priority jobs in appendix, it seems to be possible to get rid of variable J^{X+}_j by just replacing the equality in equation 3.3 by an inequality







Reviewer Confidential Comments to Editor:

For each question, please use the following scale to answer (place an x in the space provided): 

"To what extent does the article meet this criterion?"

0	Fails by a large amount
1	Fails by a small amount
2	Succeeds by a small amount
3	Succeeds by a large amount
4	Not applicable

The subject addressed in this article is worthy of investigation.
	
3


The information presented was new.

2


The conclusions were supported by the data.

0


Is there a financial or other conflict of interest between your work and that of the authors?

NO


Please give a frank account of the strengths and weaknesses of the article:




