PAPER  : #79
TITLE  : A two-stage hybrid flow shop problem with dedicated machine and release date
AUTHORS: Nabli Zouhour, Soulef Khalfallah and Ouajdi Korbaa

SCORE:
    ==  3 strong accept
    ==  2 accept
    ==  1 weak accept
    ==  0 borderline paper
    == -1 weak reject
    == -2 reject
    == -3 strong reject
-2


REVIEWER'S CONFIDENCE
    == 5 (expert)
    == 4 (high)
    == 3 (medium)
    == 2 (low)
    == 1 (none)
5


REVIEW

> Please provide a detailed review, including a justification for your scores. 
> Both the score and the review text are required.

The article treats a very special case of hybrid flowshop that consists of only 2 stages, the first stage being performed on a set of m parallel identical machines whereas the second stage is performed on 2 dedicated machines. The problem is to minimize the makespan. This problem has already been studied by the authors in the past. In this paper, some release dates are also introduced and a MIP model, some lower bounds and some heuristics are proposed.

This work is very incremental and the problem is very specific, it would be interesting to see if it is related to some practical applications.

It is strange that you mention the release dates as extensions compared to previous work but the experimental section does not seem to consider any release date. 

The proposed MIP model is essentially a disjunctive formulation with machine allocation. A main issue with this type of model is its size that grows in O(n^3). I think that when there are stages for which there are no pre-affected machines (like in the first stage of the present problem), as all the machines are equivalent, it would be better to consider the set of m parallel machines as a unique cumulative resource and maybe use some form of event-based formulations in the MIP. See for instance: Alexander Tesch. “Compact MIP Models for the RCPSP”. Tech report. ZIB. 2015.

This being said, I think that MIP is probably not the best exact approach to attack the problem. I would definitively compare the proposed approaches with Constraint Programming which is usually stronger than MIP for this type of scheduling problems. By curiosity, I tried to run the very simple CP Optimizer model [*] below (written in the OPL language). I tried a few configurations, like the one given below that corresponds to your largest problems with 100 jobs, and the CP Optimizer engine quickly finds and proves optimality in all cases (0.18s in this instance). In fact this model seems to scale and manage to solve to optimality even larger problems up to a few hundred jobs.

// DATA GENERATION (EXAMPLE FOR 100 JOBS, DU=[40,60], [N1,N2]=[50,50])

int m    = 2;
int n1   = 50;
int n2   = 50;
int Pmin = 40;
int Pmax = 60;

int n = n1+n2;
int p1[i in 1..n] = Pmin + rand(Pmax-Pmin);
int p2[i in 1..n] = Pmin + rand(Pmax-Pmin);

// CP OPTIMIZER MODEL

using CP;

dvar interval a1[i in 1..n] size p1[i];               // First stage activities
dvar interval a2[i in 1..n] size p2[i];               // Second stage activities

minimize max(i in 1..n) endOf(a2[i]);                 // Minimize makespan
subject to {
  forall(i in 1..n) { endBeforeStart(a1[i],a2[i]); }  // Precedence constraints
  sum(i in 1..n) pulse(a1[i],1) <= m;                 // Parallel machines at stage 1
  noOverlap(all(i in 1..n1) a2[i]);                   // Machine M1 at stage 2
  noOverlap(all(i in n1+1..n) a2[i]);                 // Machine M2 at stage 2
}

Here is the search log for this instances:

 ! ----------------------------------------------------------------------------
 ! Minimization problem - 202 variables, 104 constraints
 ! Initial process time : 0.00s (0.00s extraction + 0.00s propagation)
 !  . Log search space  : 1528.8 (before), 1528.8 (after)
 !  . Memory usage      : 986.3 kB (before), 986.3 kB (after)
 ! Using parallel search with 4 workers.
 ! ----------------------------------------------------------------------------
 !          Best Branches  Non-fixed    W       Branch decision
                        0        202                 -
 + New bound is 118
 *          3144      401  0.02s        1      (gap is 96.25%)
 *          3071     1167  0.03s        1      (gap is 96.16%)
 *          2994     1567  0.03s        1      (gap is 96.06%)
 *          2885     2247  0.04s        1      (gap is 95.91%)
 *          2659     3435  0.06s        1      (gap is 95.56%)
 *          2650     3435  0.06s        2      (gap is 95.55%)
 *          2625     3646  0.08s        1      (gap is 95.50%)
 *          2602     3642  0.08s        4      (gap is 95.47%)
 *          2601     4150  0.09s        4      (gap is 95.46%)
 *          2598     5273  0.12s        2      (gap is 95.46%)
            2598     5675          1    2            -
 + New bound is 2597 (gap is 0.038%)
 *          2597     6741  0.18s        4      (gap is 0%)
 ! ----------------------------------------------------------------------------
 ! Search completed, 11 solutions found.
 ! Best objective         : 2597 (optimal - effective tol. is 0)
 ! Best bound             : 2597
 ! Number of branches     : 22184
 ! Number of fails        : 3705
 ! Total memory usage     : 8.1 MB (7.6 MB CP Optimizer + 0.5 MB Concert)
 ! Time spent in solve    : 0.18s (0.17s engine + 0.00s extraction)
 ! Search speed (br. / s) : 130494.1
 ! ----------------------------------------------------------------------------

[*] I don't know which MIP solver you have been using for the experiments, but if you have been using CPLEX (in IBM ILOG CPLEX Optimization Studio), then you already have CP Optimizer and can directly use it. Otherwise, it is freely available for academic research (see: http://ibm.biz/COS_Faculty).

More detailed comments and typos:

p1: ". .All approaches ..."

p3: in the model:
  * Y_jem: there a a mix of French and English (accent on "preaffected" + "a l'etage")
  * z_ejm: "sinon"
  * u_elj: "sinon"
  * equation 2: second "+" should not appear as subscript

p5-6: in the example of section 4.2, it seems to me that after step 2, the first group of jobs should be sorted as (j1,j3,j2) instead of (j1,j2,j3) as the processing time of job 2 on second stage machine (6) is smaller than the one of j3 (7). Also as you are dealing with sorted elements, I would use a list notation (using "()") rather than set notation (using "{}"). You should also say somewhere in the example that you are considering 2 identical parallel machines for stage 1.

p7: first line: "fi[r]st"

In the experimental section, the tables are not clear at all. For instance:
- Table 2 have two sections for 10 jobs and 50 jobs but the column (n1,n2) only corresponds to the 10 jobs case. Furthermore tha caption also mention results for 100 jobs.
- The caption of Table 3 mentions results for 10, 50 and 100 jobs but the the column (n1,n2) only corresponds to the 50 jobs case.
- p12, the paragraph about the results for 50 jobs refers to table 6, but table 6 is for problem with 100 jobs.
As a consequence of all these mistakes, the experimental section is very difficult to read.

p13, in conclusion: " .Numerical results"


CONFIDENTIAL REMARKS FOR THE PROGRAM COMMITTEE 

> If you wish to add any remarks intended only for PC members please
> write them below. These remarks will only be seen by the PC members
> having access to reviews for this submission. They will not be sent
> to the authors. This field is optional.


