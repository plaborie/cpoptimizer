Title:	Exploiting Parallelism in Multi-Robot Task Allocation Problems
Authors:	(anonymous)
PC member:	Philippe Laborie

Evaluation
Significance / Importance.
* Does the paper contribute a major breakthrough or an incremental advance? If the paper describes an application, is the application important?
 3: substantial contribution or strong impact
>2: modest contribution or average impact
 1: minimal contribution or weak impact

Soundness.
* Is the technical development accurate? Does the paper present convincing evidence that supports their claims?
 3: correct
>2: minor inconsistencies or small fixable errors
 1: major errors

Novelty.
* Is the research approach described novel? For an application paper, is the application novel?
 3: novel - approach and/or application are new and only a few other similar approaches and/or applications exist
>2: moderate - approach and/or application have been developed before, but significant improvements are presented
 1: marginal - only parts of the application and/or approach are new

Scholarship.
* Is related work cited and discussed?
 3: excellent coverage of related work
>2: relevant literature cited but could be expanded
 1: important related work missing, or mischaracterizes prior research

Clarity.
* Is the paper clearly organized and clearly written? Does the submission make explicit claims about the capabilities or behavior of the approach?
 3: well organized and well written
>2: mostly readable with some room for improvement
 1: hard to follow

Technology Readiness Level.
* How would you characterize the Technology Readiness Level of the contribution
 9: Actual system proven through successful mission operations
 8: Actual system completed and qualified through test and demonstration
 7: System prototype demonstration in an operational environment
 6: System/subsystem model or prototype demonstration in a relevant environment
 5: Component and/or breadboard validation in relevant environment
 4: Component and/or breadboard validation in laboratory environment
>3: Analytical and experimental critical function and/or characteristic proof of concept
 2: Technology concept and/or application formulated
 1: Basic principles observed and reported
 0: N/A - not applicable

Reproducibility.
* Can the work be reproduced or verified based on the paper and any supporting information or data?
 5: code and data (whichever apply) are already publicly available
 4: authors promise to release code and data (whichever apply)
 3: authors describe the implementation and data in sufficient detail
>2: some details missing but still appears to be replicable with some effort
 1: difficult to reproduce because of missing detail
 0: N/A - nothing to reproduce

Suitability for Special Track.
* Is the paper suitable to the track it was submitted to
 8: Special Track on Planning and Learning - Almost all focus is on learning
 7: Special Track on Planning and Learning - Almost all focus is on planning
 6: Special Track on Planning and Learning - Good balance between planning and learning
 5: Special Track on Robotics - Almost all focus is on robotics
 4: Special Track on Robotics - Almost all focus is on planning
 3: Special Track on Robotics - Good balance between planning and robotics
 2: Novel Applications - Planning & Scheduling are not Important for the Application
 1: Novel Applications - Planning & Scheduling are Important for the Application
>0: N/A - submitted to the main track

Overall evaluation.
* Please provide an overall score.
 3: strong accept
 2: accept
 1: weak accept
 0: borderline paper
>-1: weak reject
 -2: reject
 -3: strong reject

Review.* Detailed review. (Required)

The paper's main contribution is a MIP model for a particular allocation and scheduling problem in the Multi-Robot Task Allocation taxonomy.

I'm more an expert in optimization techniques than in multi-agents and robotics so I will mainly focus on the formulation of the problem.

The paper is interesting and I'm surprised that these types of problems were not formulated before as combinatorial optimization problems.

If MIP is the selected approach for formulating the problem, I think the proposed formulation makes sense. It is in fact a fairly classical MIP formulation of disjunctive scheduling problems with Boolean variables representing resource allocation (here: allocation of tasks to agents) and the precedence decisions between tasks. But these formulations are known to scale badly, both in terms of their capacity to prove optimality of solutions and the quality of the solution they can find on larger problems where optimality cannot be proved. The number of constraints in the model grows quadratically, and even exponentially if to take into account the DFJ sub-tour elimination constraints. The small size of the problems studied in the experimental section is very illustrative of these limitations in terms of resolution.

You cite a paper by Ku & Beck about the different MIP formulation of this type of scheduling problem. One of the conclusion of the Ku & Beck paper is the following: "Comparing the best MIP results with that of CP, results show that MIP performs similarly to CP for smaller problems in terms of proving optimality. However, CP dominates MIP for larger problems both in terms of proving optimality and solution quality." I think that for the Multi-Robot Task Allocation problem considered in the present paper, a CP approach would *really* make sense and would scale much better than the proposed MIP formulation. For instance, using CP Optimizer (the alternative optimization engine, based on CP available in CPLEX Studio, see [1] for a recent review), it seems to be very easy to use the concept of state function for modeling the position of the agents over time. Allocation of tasks to agents, temporal constraints, etc. can directly be formulated with the CP constraints (alternative, end_before_start, etc...). And the other concepts of the model (cumul functions, no_overlap constraints) could be used to leverage other interesting extensions of the problem like tools/resources with limited instataneous capacity (available electrical power, number of arms of the robots, ...) or storage resources (limited memory storage for data for instance). I attach at the end of this review an example of formulation of the small problem with 6 tasks and 2 vehicles described in the paper. This model would allow finding feasible (and hopefully good quality) solutions to much larger problems than the ones mentioned in the paper and probably be better than MIP at proving optimality (at least, as long as the criterion is the makespan).

[1] P. Laborie, J. Rogerie, P. Shaw, P. Vilim. "IBM ILOG CP Optimizer for Scheduling". Constraints journal 23(2), 210-250, 2018. https://ibm.biz/Constraints2018 


Detailed questions:

- "For example, a robot with two arms manipulating two different objects can be interpreted as parallel execution of two separate/independent tasks. Consequently, these tasks can be modeled as a single monolithic task,". It is not clear to me. It may be part of the decisions of the problem to decide when these individual two tasks are executed. And it may be decided to execute them at very different time, or in parallel so how is it possible to consider them as a monolithic task (except if you over-constrain the problem) ? This seems to me a case where you would represent the robot arms as a cumulative resource of capacity 2 (see "cumul functions" above) and let the solution decide how tasks (requiring 0, 1 or 2 robot hands) are executed in parallel of not, provided that the arm capacity of the robot is not exceeded.

- "Similarly, also mixed parallelism may sometimes be not possible, for example because of functional dependencies among the tasks, or because of physical limitations, e.g., scanning the seabed using sonar and using an acoustic modem for communication is not possible due to possible interference in under water": this seems to be a typical use case of "state functions" where the condition for executing the seabed scan using sonar is that the state of the sea is not "perturbed", like it is when using an acoustic modem (stated otherwise, the two tasks require incompatible states)

- "We finally define the matrix R ..." In case of cumulative resources (simple example: a tool that can perform not more than 3 tasks in parallel, another example is the robot with 2 arms), a non-overlap matrix is not sufficient. Would it not be more efficient to directly formulate in the model the constraints that limit the possibility to execute tasks in parallel: executed by a resource/equipement that can perform only one or N task at a time, resource like electrical power with limited capacity, incompatibility between required positions (typical case of physical tasks) or between required state of an equipment, or of the environment (like the sea state in the above example)... If the optimization framework supports concept to formulate these type of constraints (and CP does), this will result in more compact and efficient formulations.


Questions for rebuttal
----------------------

Q1: Did you try using CP techniques to formulate the problem ?


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
>> Python formulation in CP Optimizer, same formulation could be 
>> implemented in Java, C++ or OPL
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

from docplex.cp.model import *
model = CpoModel()

# Interval variables representing the origin of agents
# (fixed intervals [-1,0))
# See CP Optimizer concept "interval variable"
OV1 = interval_var(size=1,start=-1)
OV2 = interval_var(size=1,start=-1)
# Intervals representing the destination of agents
DV1 = interval_var(size=1)
DV2 = interval_var(size=1)
# Intervals representing tasks and task allocations to candidate agents
# depending on agent's equipment
T1 = interval_var(size=200) # Candidate agent T1 :
T1V1 = interval_var(optional=True)
T2 = interval_var(size=280) # Candidate agent T1 :
T2V1 = interval_var(optional=True)
T3 = interval_var(size=240) # Candidate agents T1 or T2 :
T3V1 = interval_var(optional=True)
T3V2 = interval_var(optional=True)
T4 = interval_var(size=220) # Candidate agent T2 :
T4V2 = interval_var(optional=True)
T5 = interval_var(size=300) # Candidate agent T2 :
T5V2 = interval_var(optional=True)
T6 = interval_var(size=480) # Candidate agent T1 or T2 :
T6V1 = interval_var(optional=True)
T6V2 = interval_var(optional=True)

# Travel time matrix
# Locations:
# 0 : Agent origin (assuming identical for all agents, so single location)
# 1 : Agent destination (assuming identical for all agents, so single location)
# 2 : Position A
# 3 : Position B
# 4 : Position C
POSA, POSB, POSC = 2, 3, 4
# Example of simple transition matrix (all points are equidistants)
# See CP Optimizer concept "transition distance"
M = [ [ 250*(i!=j) for i in range(5) ] for j in range(5) ]

# State function variables representing the position of agents
# with travel time matrix between states (positions)
# See CP Optimizer concept "state function"
POSV1 = state_function(M)
POSV2 = state_function(M)

# Constraints
model.add( [
  # Temporal constraints between tasks
  start_before_start(T3,T6), 
  end_before_start  (T4,T5),
  end_before_start  (T2,T1),
  # Continuity constraints related with precedence constraints:
  # the two tasks must be performed by the same agent
  presence_of(T4V2) == presence_of(T5V2),
  presence_of(T3V1) == presence_of(T6V1),
  presence_of(T3V2) == presence_of(T6V2),
  presence_of(T2V1) == presence_of(T1V1),
  # Allocation of tasks to possible agents
  alternative(T1, [T1V1]),
  alternative(T2, [T2V1]),
  alternative(T3, [T3V1, T3V2]),
  alternative(T4, [T4V2]),
  alternative(T5, [T5V2]),
  alternative(T6, [T6V1, T6V2]),
  # Agents tasks before destination task
  end_before_start (T1V1, DV1),
  end_before_start (T2V1, DV1),
  end_before_start (T3V1, DV1),
  end_before_start (T6V1, DV1),
  end_before_start (T3V2, DV2),
  end_before_start (T4V2, DV2),
  end_before_start (T5V2, DV2),
  end_before_start (T6V2, DV2),
  # Agents position at origin and destination
  always_equal(POSV1, OV1, 0),
  always_equal(POSV1, DV1, 1),
  always_equal(POSV2, OV2, 0),
  always_equal(POSV2, DV2, 1),
  # Agents position constraint for physical tasks
  always_equal(POSV1, T2V1, POSC),
  always_equal(POSV1, T3V1, POSB),
  always_equal(POSV2, T4V2, POSA),
  always_equal(POSV2, T3V2, POSB)
])

# Objective function: minimize latest end of agents schedule
model.add(minimize(max([start_of(DV1),start_of(DV2)])))

# Solve
sol = model.solve()

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>



Reviewer's confidence.
* Reviewer's confidence
 4: (expert)
 3: (high)
>2: (medium)
 1: (low)
 
Suitable for a demo?.
* Suitable for a demo?
 3: yes
 2: maybe
 1: no
 
Nominate for Best Paper Award?. 
 yes

Nominate for Best Student Paper Award (assuming it is eligible) ?. 
 yes
 
Confidential remarks for the program committee. 
If you wish to add any remarks intended only for PC members please write them below. These remarks will only be seen by the PC members having access to reviews for this submission. They will not be sent to the authors. This field is optional.


