TPRS-2017-IJPR-1071

Minimizing Total Weighted Completion Time on Batch and Discrete Machines with Incompatible Job Families
*= Required Fields [Yes/No]

* 1. Does the paper make a new and significant contribution to the Production Research literature?	
Yes

* 2. Does the paper provide evidence of real or potential application for Production Systems?	
Yes

* 3. Is adequate credit given to other contributors in the field and are references sufficiently complete?	
Yes

* 4. Does the paper appropriately compare the performance of proposed methodologies with those found in the published literature?
Yes

* 5. Does the paper state what the author(s) propose to do in the future?	
Yes

* 6. Are the character and contents of the paper clear from the title and abstract?	
Yes

* 7. Is the paper clearly, concisely, accurately, and logically written?	
Yes

* 8. Could it benefit from condensing or expansion? If yes, please explain why in the comments to author section.	
No

* 9. Is the subject matter of relevance to Production Research and appropriate for IJPR?	
Yes

* 10. Are all references relevant? If not please indicate in your review not relevant references.	
Yes
 
Would you be willing to review a revision of this manuscript?
[X] Yes
[ ] No

Recommendation
[X] Accept
[ ] Minor Revision
[ ] Major Revision
[ ] Reject but allow Resubmission
[ ] Reject


Confidential Comments to the EIC
Only confidential information that you do not wish to be passed to the Authors should be entered here.


*Comments to the Author
Please give your remarks to the authors. Without this, your review will be cancelled.

The readability of the article has again been improved since the previous submission. 

The only part that would I think deserve more attention is the section about the constraints related with the week-ends, following my comment in the previous review, and the authors answer:

>> Q:
>> On page 17, the part of the model related with constraints 19-21 is still not very clear. 
>> Is it not the case that constraints (19) and (20) are subsumed by constraint (20)? 
>> In fact it seems to me that you could use the concept of "intensity function" to 
>> formulate these constraints more directly in the model. If the constraints is that a 
>> certain amount of time equal to AgingTime_i must elapse between the breaks, then it is 
>> exactely what intensity functions stand for. The formulation of these constraints (19-20) 
>> result in very weak inferences in the engine so alternative formulations could help a lot here. 

> A:
> Thank you for the comments. When there is enough time to complete the aging and emptying
> processes during the working weekdays, the pre-define aging time for each product is assigned to aging
> interval. This is formulated by equation 19. However, when aging starts at the end of one week and
> needs to be processed and stored over the weekend, the main objective of the aging interval is to
> maintain process continuity over the two successive production weeks. Hence it will be difficult to
> determine the actual length of the aging interval because it is affected by the starting time of the aging,
> and pre-defined aging time of the product. For example, if a product has 4 hours of aging time and the
> process started at hour 117 then the length of the aging interval will be 3 hours to get to 120 which is
> starting point of the following week. The missing hour is completed over the weekend. On the other
> hand, if the aging time is 2 hours and the process started at 117 then the aging interval will still be 3
> hours even though under the normal procedure it should have been 2. In real time, the product stays in
> the vessel for a total of 51 hours (3 hour over the weekdays + 48 hours over the weekend). This is
> formulated by equation 20. We could not formulate this feature as neither as intensity function nor as
> forbidden constraint due this peculiar nature of problem

If I understand well, the production line works 24hx24h except for the week-end, and just before the week-end, the production activities must stop 2h before the week-end break (so, say at 10:00PM on Friday). It seems that the current model just rules out the 48h of the week-end (these 48h are not seen on the time-scale of the schedule) and uses stepFunctions only to account for the 2h changeover idle-time. Because of these missing 48h, specific constraints (19 and 20) need to be modeled when dealing with constraints like the minimal aging process duration that deal with "real time" (in opposition to "production time"). I think that it would be possible and much more clear and more efficient to work only with "real time": you would have a step function that is 100% during production time and 0% outside production time (so covering both the 2h changeover idle-time AND the 48h of the week-end):

Week = 7days = 168 hours (Note the difference here, as we work on the real time scale, a week is 7*24=168 hours)
stepFunction WeekendBreak =  100%  if           0 <= t < (l*Week)-50
                          =    0%  if (l*Week)-50 <= t < (l*Week)

This way, this new step function WeekendBreak can be used:
- as before in the forbidExtent constraints for the interval variables that are production activities that cannot be interrupted by a week-end so they must be fully executed during the same week (FillAssign, FreezeAssign,PackAssign)
- the interval variables AgeProcessV_ib would have a minimal length MinAgingTime_i: length(AgeProcessV_ib)>=MinAgingTime_i and additionally, a constraint that says that they cannot end during the week-end so: forbidEnd(AgeProcessV_ib, WeekendBreak)

Even better, I think that by working on the "real time" scale, you do not need the interval variables AgeProcessV_ib and WaitProcess_ib anymore (they do not seem to require any equipment and are just technical intervals to formulate the minimal aging time on the "real time" scale between FillAssign_ib and FreezeAssign_ib). So you could just add precedence constraints: endBeforeStart(FillAssign_ib, FreezeAssign_ib, MinAgingTime_i)

To make it clear, let's take your example:
> For example, if a product has 4 hours of aging time and the
> process started at hour 117 then the length of the aging interval will be 3 hours to get to 120 which is
> starting point of the following week. The missing hour is completed over the weekend. On the other
> hand, if the aging time is 2 hours and the process started at 117 then the aging interval will still be 3
> hours even though under the normal procedure it should have been 2. In real time, the product stays in
> the vessel for a total of 51 hours (3 hour over the weekdays + 48 hours over the weekend). This is
> formulated by equation 20. We could not formulate this feature as neither as intensity function nor as
> forbidden constraint due this peculiar nature of problem

If you work on the real time scale, the WeekendBreak function is: 100% on [0,118), 0% on [118,168), 100% on [168,286) ...

If the aging process starts at 117 and minimal aging time is 3h, because of the forbidEnd, the AgeProcessV_ib will have to end after the week-end so after 168. So as you say, the product will stay in the vessel for a total of 51 hours (168-117), this is now explicit in the model. And (even better) if you do not use the AgeProcessV_ib and WaitProcess_ib intervals anymore, the constraint endBeforeStart(FillAssign_ib, FreezeAssign_ib, 3h) together with the constraint forbidExtent(FreezeAssign_ib, WeekendBreak) will ensure that FreezeAssign_ib cannot start earlier than the end of week-end at date 168.

I would expect this issue to be addressed in the final version of the article as it simplifies the description of the model and could also improve the performances of the CP model.

Other minor comments:

- p3, line 3-5: "CP constraints can be framed as a linear equation or inequality, conjunctive or disjunctive function, 
  or cumulative function (Sitek & Wikarek, 2015)": 
this is very limitative, there are *many* other types of constraints available in CP! Instead you could say 
something like: "The CP paradigm is very general and allows for many type of constraints like linear 
inequalities or disequalities, disjunctions of constraints, global constraints (allDifferent, cumulative), etc."

- p11, first two sentences:
"Scheduling problems can be formulated using different approaches in CP. The most
common approach is to define processes using bounding, binary, or both types of decision
variables and then adopt constraint functions and propagating algorithms to solve the problem
(Laborie & Rogerie, 2008). IBM CP optimization tool provides a different approach where the
processes and respective sequences are formulated as decision variables. This tool incorporates
different model formulation approaches which include global constraints construction, modeling
layers creation (for processing activities and resources), and methods for generating optional
processing activities (Laborie, Rogerie, Shaw, & Vil√≠m, 2009)."

The formulation suggests that the modeling concepts presented in the cited paper are different from the 
ones implemented in the IBM CP optimization tool (by the way, you could use "IBM CP Optimizer tool") 
whereas on the contrary, the paper presents the modeling concepts used in CP Optimizer. 
I would rephrase this part. Maybe something like:

"Scheduling problems can be formulated using different approaches in CP. The most
common approach is to define processes using _integer_ and/or _binary_ decision
variables and a set of global constraints and propagation algorithms to solve the problem. 
The IBM CP Optimizer tool (Laborie & Rogerie, 2008) provides a different approach where the
processes and respective sequences are formulated as _interval_ and _sequence_ decision variables.
This tool introduces some modeling concepts for scheduling problems for representing optional 
activities, temporal constraints, hierarchical decomposition and different resource-related constraints"



