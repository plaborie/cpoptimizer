Question 1.

Les affirmations suivantes sont-elles vraies ou fausses:

a- Un problème de décision est dans la classe de complexité NP si et seulement si il n'existe pas d'algorithme polynomial pour le résoudre.

FAUX. Un problème de décision est dans la classe NP si il est décidable en temps polynomial par une machine de Turing non déterministe. Cela revient à dire qu'un problème de décision est dans la classe NP si on peut vérifier en temps polynomial qu'une solution donnée est faisable. De nombreux problèmes de la classe NP peuvent être résolus en temps polynomial.

b- Dans l'industrie, la majorité des problèmes d'ordonnancement sont résolus grâce à des heuristiques.

VRAI. La plupart du temps les problèmes d'ordonnancement dans l'industrie sont résolus de manière manuelle ou en appliquant de simples heuristiques.

c- Le problème suivant possède exactement trois solutions:
   u in {1,3}
   v in {1,2}
   w in {3,4}
   x in {1,5}
   y in {4,5}
   allDifferent(u,v,w,x,y)

FAUX. Il possède deux solutions qui sont: (u,v,w,x,y)=(1,2,3,5,4) et (u,v,w,x,y)=(3,2,4,1,5)

Question 2.

a- En cherchant sur internet, décrivez un problème d'optimisation combinatoire non vu dans le cours dont la version de décision est un problème NP-Complet.

On peut trouver la description de nombreux problèmes d'optimisation combinatoires qui sont NP-Complet.
Attention, la question portait sur des problèmes d'optimisation, donc plutôt sur des problèmes devant minimiser (ou maximiser) un certain critère.
Voici plusieurs problèmes mentionnés dans les réponses correctes à cette question:

- Problème du postier Chinois (https://fr.wikipedia.org/wiki/Problème_du_postier_chinois)
- Problème de partition en clique (https://fr.wikipedia.org/wiki/Partition_en_cliques)
- Problème d'ensemble indépendant (stable) maximal dans un graphe (https://fr.wikipedia.org/wiki/Stable_(théorie_des_graphes))
- Problème du sac à dos (maximiser la valeur totale liée à un certain nombre d'objets, sous contrainte de poids total du sac à dos). https://fr.wikipedia.org/wiki/Probl%C3%A8me_du_sac_%C3%A0_dos
- Problème de plus longue sous-séquence commune (attention, si le nombre de séquences en entrée est fixé, par exemple 2, le problème est polynomial en fonction de la taille des données: ici la longueur totale des séquences)
- Problème de l'apport en vitamines avec minimisation du coût et utilisation de variables entières (proche de: https://neos-guide.org/content/diet-problem)
- Problème de coloration de graphe: https://fr.wikipedia.org/wiki/Coloration_de_graphe
- Problème de clique maximale dans un graphe: https://fr.wikipedia.org/wiki/Probl%C3%A8me_de_la_clique
- Problème de couverture d'un graphe par sommets: https://fr.wikipedia.org/wiki/Probl%C3%A8me_de_couverture_par_sommets
- Problème de l'arbre de Steiner (NP_Complet dans la plupart des versions)
- Problème d'ordonnancement de tâches sur une seule machine sans préemption, avec indisponibilité de machine. Qui se ramène facilement à un problème de bin-packing: https://fr.wikipedia.org/wiki/Probl%C3%A8me_de_bin_packing
- Jeu de Tétris, à supposer que l'on veuille maximiser le nombre de lignes effacées: https://link.springer.com/chapter/10.1007/3-540-45071-8_36

Des problèmes de décision (correctement identifiés comme NP-Complets) ont aussi été mentionnés:
- Problème de l'existence d'un chemin Hamiltonien dans un graphe
- Problème de la somme de sous-ensembles: https://fr.wikipedia.org/wiki/Probl%C3%A8me_de_la_somme_de_sous-ensembles
- Picross ou nonogrammes: https://fr.wikipedia.org/wiki/Picross
- Reconnaissance d’un graphe de disques unitaire: https://en.wikipedia.org/wiki/Unit_disk_graph#Computational_complexity

D'autres problèmes mentionnés dans les réponses n'étaient pas NP-Complets (Maximal Spanning Tree, Couverture des sommets d'un graphe par un sous-ensemble d'arcs) ou bien insuffisamment spécifiés pour être clairement identifiés comme étant NP-Complets (problème d'appariement minimal).

Le problème des n-dames (ou n-queens) a été mentionné dans une réponse. Le problème de décision des n-dames est résoluble en temps constant car on peut montrer qu'il existe des solutions pour tout n>3 (donc le problème de décision n'est pas NP-Complet). Sur ce sujet, voir par exemple: https://www.ijcai.org/proceedings/2018/0794.pdf. Le problème de comptage des solutions du problème des n-dames n'est quant à lui pas à proprement parler un problème d'optimisation mais un problème de comptage (je n'ai pas évoqué ces problèmes pendant le cours) pour lesquels ont été développés d'autres mesures de complexité. Sur ce sujet, voir par exemple: https://www.ijcai.org/proceedings/2018/0794.pdf

b- Décrivez une petite instance particulière de ce problème d'optimisation (avec des valeurs pour chacune des données).

c- Donnez une solution faisable non-optimale et une solution optimale de cette instance.


Question 3.

Deux principes fondamentaux de la Programmation par Contraintes sont (1) la recherche arborescente et (2) le filtrage du domaine des variables. Décrivez brièvement ces principes, leurs rôles et la façon dont ils sont mis en oeuvre durant la résolution.

1. Recherche arborescente. En Programmation par Contraintes, la recherche arborescente permet d'explorer l'espace de recherche sous la forme d'un arbre de recherche. A chaque noeud de l'arbre, une variable de décision encore non-instanciée 'x' est selectionnée et on crée un noeud fils du noeud courant pour chacune des valeurs {v1,...,vn} dans le domaine courant de la variable x. L'arbre de recherche permet d'explorer de manière exhaustive toutes les solutions du problème.

2. Filtrage du domaine des variables: en cours d'exploration de l'arbre de recherche, des décisions sont prises (par exemple d'affecter la valeur v1 à la variable x dans une branche de l'arbre). Des algorithmes de filtrage sont exécutés afin d'enlever du domaine des variables un certain nombre de valeurs dont on peut prouver qu'elles ne peuvent être prises dans aucune solution faisable du sous-arbre. Le filtrage du domaine des variables est exécuté à chaque noeud de l'arbre de recherche (et pas seulement au noeud racine), dès que le domaine d'une variable est réduit. Le filtrage permet d'élaguer l'arbre de recherche.
