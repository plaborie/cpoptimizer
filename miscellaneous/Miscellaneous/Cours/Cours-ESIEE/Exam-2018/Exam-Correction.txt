Question 1.

Les affirmations suivantes sont-elles vraies ou fausses:

a- Un problème de décision est dans la classe de complexité NP si et seulement si il n'existe pas d'algorithme polynomial pour le résoudre.

FAUX. Un problème de décision est dans la classe NP si il est décidable en temps polynomial par une machine de Turing non déterministe. Cela revient à dire qu'un problème de décision est dans la classe NP si on peut vérifier en temps polynomial qu'une solution donnée est faisable. De nombreux problèmes de la classe NP peuvent être résolus en temps polynomial.

b- Dans l'industrie, la majorité des problèmes d'ordonnancement sont résolus grâce à la Programmation Linéaire (MIP).

FAUX. La plupart du temps les problèmes d'ordonnancement dans l'industrie sont résolus de manière manuelle ou en appliquant de simples heuristiques.

c- Le problème suivant possède exactement deux solutions:
   u in {1,2}
   v in {1,3}
   w in {3,4}
   x in {4,5}
   y in {1,5}
   allDifferent(u,v,w,x,y)
   
VRAI. Les deux solutions sont: (u,v,w,x,y)=(2,1,3,4,5) et (u,v,w,x,y)=(2,3,4,5,1)

Question 2.

a- En cherchant sur internet, décrivez un problème d'optimisation combinatoire non vu dans le cours dont la version de décision est un problème NP-Complet.

On peut trouver la description de nombreux problèmes d'optimisation combinatoires qui sont NP-Complet. Attention, la question portait sur des problèmes d'optimisation, donc plutôt sur des problèmes devant minimiser (ou maximiser) un certain critère. Voici plusieurs problèmes mentionnés dans les réponses correctes à cette question:

- Problème du sac à dos (maximiser la valeur totale liée à un certain nombre d'objets, sous contrainte de poids total du sac à dos). https://fr.wikipedia.org/wiki/Probl%C3%A8me_du_sac_%C3%A0_dos
- Problème de l'apport en vitamines avec minimisation du coût et utilisation de variables entières (proche de: https://neos-guide.org/content/diet-problem)
- Problème de coloration de graphe: https://fr.wikipedia.org/wiki/Coloration_de_graphe
- Problème de clique maximale dans un graphe: https://fr.wikipedia.org/wiki/Probl%C3%A8me_de_la_clique
- Problème de couverture d'un graphe par sommets: https://fr.wikipedia.org/wiki/Probl%C3%A8me_de_couverture_par_sommets
- Problème d'ordonnancement de tâches sur une seule machine sans préemption, avec indisponibilité de machine. Qui se ramène facilement à un problème de bin-packing: https://fr.wikipedia.org/wiki/Probl%C3%A8me_de_bin_packing
- Jeu de Tétris, à supposer que l'on veuille maximiser le nombre de lignes effacées: https://link.springer.com/chapter/10.1007/3-540-45071-8_36

Des problèmes de décision (correctement identifiés comme NP-Complets) ont aussi été mentionnés:
- Problème de la somme de sous-ensembles: https://fr.wikipedia.org/wiki/Probl%C3%A8me_de_la_somme_de_sous-ensembles
- Picross ou nonogrammes: https://fr.wikipedia.org/wiki/Picross
- Reconnaissance d’un graphe de disques unitaire: https://en.wikipedia.org/wiki/Unit_disk_graph#Computational_complexity

D'autres problèmes mentionnés dans les réponses n'étaient pas NP-Complets (Maximal Spanning Tree) ou bien insuffisamment spécifiés pour être clairement identifiés comme étant NP-Complets (problème d'appariement minimal).

Le problème des n-dames (ou n-queens) a été mentionné dans une réponse. Le problème de décision des n-dames est résoluble en temps constant car on peut montrer qu'il existe des solutions pour tout n>3 (donc le problème de décision n'est pas NP-Complet). Sur ce sujet, voir par exemple: https://www.ijcai.org/proceedings/2018/0794.pdf. Le problème de comptage des solutions du problème des n-dames n'est quant à lui pas à proprement parler un problème d'optimisation mais un problème de comptage (je n'ai pas évoqué ces problèmes pendant le cours) pour lesquels ont été développés d'autres mesures de complexité. Sur ce sujet, voir par exemple: https://www.ijcai.org/proceedings/2018/0794.pdf

b- Décrivez une petite instance particulière de ce problème d'optimisation (avec des valeurs pour chacune des données).

c- Donnez une solution faisable non-optimale et une solution optimale de cette instance.


Question 3.

Deux principes fondamentaux de la Programmation par Contraintes sont (1) la recherche arborescente et (2) le filtrage du domaine des variables. Décrivez brièvement ces principes, leurs rôles et la façon dont ils sont mis en oeuvre durant la résolution.

1. Recherche arborescente. En Programmation par Contraintes, la recherche arborescente permet d'explorer l'espace de recherche sous la forme d'un arbre de recherche. A chaque noeud de l'arbre, une variable de décision encore non-instanciée 'x' est selectionnée et on crée un noeud fils du noeud courant pour chacune des valeurs {v1,...,vn} dans le domaine courant de la variable x. L'arbre de recherche permet d'explorer de manière exhaustive toutes les solutions du problème.

2. Filtrage du domaine des variables: en cours d'exploration de l'arbre de recherche, des décisions sont prises (par exemple d'affecter la valeur v1 à la variable x dans une branche de l'arbre). Des algorithmes de filtrage sont exécutés afin d'enlever du domaine des variables un certain nombre de valeurs dont on peut prouver qu'elles ne peuvent être prises dans aucune solution faisable du sous-arbre. Le filtrage du domaine des variables est exécuté à chaque noeud de l'arbre de recherche (et pas seulement au noeud racine), dès que le domaine d'une variable est réduit. Le filtrage permet d'élaguer l'arbre de recherche.


Question 4.

Un problème classique en ordonnancement est le problème d'open-shop pour lequel un ensemble de n jobs doivent être exécuté sur m machines. Chaque job consiste en un ensemble de m opérations de durée connue, devant être exécutées dans un ordre arbitraire sur les machines. Plus précisément, si l'opération o_ij désigne la jème opération du job i, cette opération utilise la machine j et sa durée est D_ij. Les m opérations o_ij d'un job donné i doivent être ordonnées mais cet ordre est libre. Une machine ne peut pas effectuer plus d'une opération à la fois. L'objectif est de déterminer les dates de début et de fin de chaque opération de manière à minimiser la date de fin du plan. Ce problème d'optimisation est NP-difficile.

Les données d'entrée du problème sont donc:
- n, le nombre de jobs
- m, le nombre de machines
- D_ij (i in [1,n], j in [1,m]), la durée de la jème opération du job i

a- Décrivez un modèle CP Optimizer à base de variables d'intervalles et de contraintes noOverlap pour résoudre le problème d'open-shop. 

Les variables de décisions du problème sont des variables d'intervalle x_ij pour chaque opération. La variable x_ij représente l'opération j du job i. Cette opération est exécutée par la machine j. La longueur de l'intervalle x_ij est la durée de l'operations, soit D_ij.

L'objectif est de minimiser la date de fin du plan, donc la date maximale parmi toutes les fins d'opérations:

minimize max_ij endOf(x_ij)

Il y a deux types de contraintes dans le problème d'open-shop:

Tout d'abord les contraintes imposant que toutes les opérations x_ij d'un même job i ne peuvent s'intersecter. Ceci se modélise en déclarant une contrainte de no-overlap pour chaque job i:

no-overlap([x_ij]_{j in [1,m]})    forall i in [1,n]

Ensuite, nous avons les contraintes liées aux machines qui ne peuvent effectuer qu'une opération à la fois. Ici encore nous pouvons poster une contrainte no-overlap entre toutes les opérations x_ij exécutées par machine j:

no-overlap([x_ij]_{i in [1,n]})    forall j in [1,m]

Ce qui nous donne un modèle complet du type:

minimize max_{i in [1,n],j in [1,m]} endOf(x_ij)
subject to:
  no-overlap([x_ij]_{j in [1,m]})         forall i in [1,n]
  no-overlap([x_ij]_{i in [1,n]})         forall j in [1,m]
  
interval x_ij size D_ij                   forall i in [1,n], j in [1,m]


b- Décrivez un modèle CP Optimizer pour une variante du problème d'open-shop pour laquelle les machines peuvent effectuer au plus deux opérations en parallèle.

Dans le cas où les machines peuvent effectuer 2 opérations en parallèle, à la place des contraintes no-overlap sur les machines, nous pouvons utiliser une fonction de cumul qui représente le nombre d'opérations en cours d'exécution à l'instant t sur une machine donnée et contraindre cette function à être toujours inférieure à 2. Ce qui nous donne un modèle complet du type:

minimize max_{i in [1,n],j in [1,m]} endOf(x_ij)
subject to:
  no-overlap([x_ij]_{j in [1,m]})         forall i in [1,n]  
  sum_{i in [1,n]} pulse(x_ij,1)  <= 2    forall j in [1,m]
  
interval x_ij size D_ij                   forall i in [1,n], j in [1,m]


