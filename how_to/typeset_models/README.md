A document proposing a way to typeset CP Optimizer models in LaTeX is available [here](conventions.pdf).

Here is the adaptation of these conventions that we will adopt for typesetting CP Optimizer models in text format.

## Scopes

A scope is a set of tuples used for indexing. For describing a scope, we use the
classical set notation. For instance if N and M are two integers:
* `i in [N..M]` is the set of all integers i in {N,N+1,...M} (assuming N<=M) 
* `i in [N..M)` is the set of all integers i in {N,N+1,...M-1}
* `i in [1..N], j in [1..M]` is the cartesian product (i,j) in [1,N]x[1,M]
* `i,j in [1..N] | i!=j` is the subset of the cartesian product [1,N]x[1,N] such that i!=j

When the order of the elements in the scope is important (like for instance
in the vectors or matrices below), the tuples are supposed to be generated by
iterating on the indexes from left to right. For instance:
`i,j in [1..3] | i!=j` will generate the ordered set of tuples (1,2),(1,3),(2,1),(2,3),(3,1),(3,2).

## Vectors

Vectors are denoted `[v1,v2,...,vn]` or `[ v(s) : s in SCOPE ]`

For instance:
* `V1 = [i : i in [1..5]]` is vector `[1,2,3,4,5]`
* `V2 = [i+j: i,j in [1..3] | i!=j]` is vector `[3,4,3,5,4,5]` (see section 'Scopes' above)

Vectors are indexed by the tuples in the scope. If `V` is a vector and `s` a tuple in its scope, the value of `V` for tuple `s` is `V[s]`.

For the examples above:
* `V1[1]=1, V1[2]=2, ...` 
* `V2[1,2]=3, V2[1,3]=4,...`

## Sets

Sets are denoted `{v1,v2,...,vn}` or `{ v(s) : s in SCOPE }`

For instance:
* `S1 = {i : i in [1..5]}` is set `{1,2,3,4,5}`
* `S2 = {i+j: i,j in [1..3] | i!=j}` is set `{3,4,5}` (see section 'Scopes' above)

## Matrices

Matrices are vectors of vectors.

For instance matrix `M = [ [ |i-j| : i in [1..3] ] : j in [1..3] ]` is matrix:

```
         |  M[1][1]  M[1][2]  M[1][3]  |     |  0  1  2  |
   M  =  |  M[2][1]  M[2][2]  M[2][3]  |  =  |  1  0  1  |
         |  M[3][1]  M[3][2]  M[3][3]  |     |  2  1  0  |
```

## Decision variables

CP Optimizer provides different types of decision variables (integer, interval, sequence, state function). The general syntax for defining a decision variable is:

```
TYPE NAME    DOMAIN
TYPE NAME[s] DOMAIN : s in SCOPE
```
The second construction will create a vector `NAME` of decision variables indexed by scope `s`.

As a rule of thumb, we denote decision variables with lower cases whereas constants of the problem (including known stepwise or piecewise linear functions) are denoted with upper cases.

### Integer variables

The keyword for the type of an integer variable is `integer`. The domain is a set of integers. So for instance we can have:

```
integer x      in [1..N]
integer y[i]   in [2k+1 : k in [0..M)]  : i in [1..N]
integer z[i,j] in [0,1]                 : i,j in [1..N] | i!=j
```

### Interval variables

The keyword for the type of an interval variable is `interval`. The domain is a subset of domain specifiers in the following order, separated by a comma:
* Minimal start (R) and maximal end (D) range: `in [R..D]` (default: `in [0..+oo]`)
* Specification whether the interval is optional: `optional` (default: not optional that is, interval is present)
* Value or range for the interval size: `size = S` or `size in [S1..S2]` (default: `size in [0..+oo]`)
* Intensity function (stepwise function F): `intensity = F` (default: no intensity)

For instance:

```
interval x 
interval y[i] in [-H..H]                                                  : i in [1..N]
interval z[i,j] in [0..H], optional, size in [A[i],B[i]], intensity=F[j]  : i in [1..N], j in [1..M] 
```

### Sequence variables

The keyword for the type of a sequence variable is `sequence`. The domain is a vector `X` of interval variables (see section Vector above). Optionally, the domain can specify a vector of integer types `T` (`T` must have the same dimension as `X`). For instance:

```
sequence s[i] in [x[i,j] : j in [1..M]]                                 : i in [1..N]
sequence r[i] in [x[i,j] : j in [1..M]], types [[T[i,j] : j in [1..M]]  : i in [1..N]
```

### State functions

The keyword for the type of a state function is `stateFunction`. The domain of a state function can specify a matrix of integers as transition distance between the states. For instance:

```
stateFunction f[k]                                : k in [1..M] 
stateFunction g[k] with [D[i,j] : i,j in [0..S)]  : k in [1..M] 
```



## Constraints

Constraints are defined as follows:

```
CONSTRAINT
CONSTRAINT[s] : s in SCOPE
```

The signature of the different constraints available in CP Optimizer is summarized below. 

| Keyword                         | Short description     |
| ------------------------------- | -------------         |
| =, !=, <=, >=, <, >             | Classical arithmetical constraints   |
| allDifferent(V)                 | Global all different constraint   |
| pack(U,V,A,w)                   | Bin-packing constraint   |
| allMinDistance(U,a)             | Minimal distance between all values   |
| inverse(U,V)                    | Inverse constraint   |
| allowedAssignments(U,M)         | Allowed combinations of values   |
| forbiddenAssignments(U,M)       | Forbidden combinations of values   |
| lexicographic(U,V )             | Lexicographic ordering constraint   |
| presenceOf(x)                   |  Presence of an interval variable   |
| [start/end][Before/At][Start/End](x,y,a) | Precedence constraints |
| forbid[Start/End/Extent](x,stp) | Forbidden values   |
| alternative(x,Y,u)              | Alternative   |
| span(x,Y)                       | Span   |
| noOverlap(s,M,bool)             | No-overlap   |
| first(s,x)                      | First on a sequence   |
| last(s,x)                       | Last on a sequence   |
| prev(s,x,y)                     | Immediately before on a sequence   |
| before(s,x,y)                   | Before on a sequence   |
| sameSequence(r,s,X,Y)           | Same sequence   |
| sameCommonSubsequence(r,s,X,Y)  | Same common subsequence   |
| isomorphism(X,Y)                | Isomorphism   |
| alwaysIn(f,x,a,b)               | Always-in constraint on cumul or state function   |
| alwaysEqual(sf,x,a,bool,bool)   | Always-equal constraint on state function   |
| alwaysConstant(sf,x,bool,bool)  | Always-constant constraint on state function   |
| alwaysNoState(sf,x)             | Always-no-state constraint on state function   |

For instance:

```
v[i] <= v[j]                : i,j in [1..N] | i<j
endBeforeStart(x[i],x[i+1]) : i in [1..N)
```
